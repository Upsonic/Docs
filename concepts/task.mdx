---
title: 'Task-Centric Structure'
description: 'Design your tasks in a crystal clear format.'
icon: bullseye
---

The tasks are define the job that we want to make done via agent. In Upsonic framework you can clearly define your task via `Task` class. The tasks can be run via agents or direct llm calls. As first of all your works, you need to define the task. Tasks are also have some parameters, `tools` and `context`. This definations helps you to build an comprehensive systems. With context, you can connect your task to another task or giving an knowledge base.

**You dont need to create tasks as step of your job. Agent will automatically generate this steps.**

We create this mechanism to be clear at the tasks. The other systems use interactions and non-task structures. This way create two problem; first, you cannot use the agents for varously tasks. In other way you need to use your agent for only one job. Second problem is non-programmatic situation. When you create an task. You have some dependencies like the website you reffered, the company you sad or the competitor. If you don't have systems like tasks. You need to define this things inside of your agent and like the first problem its creates an non-programmatic structure. You shouldn't create agents for every competitor analyses in a for loop.

## Creating a Task

Task class is belongs to `upsonic` so you can easily import. After the import you can define your task as task1, task2, task3 and more.&#x20;

```python
from upsonic import Task

task1 = Task(description="Making an deep analyze for US history")
```

## Task Attributest

The tasks are can be basic or complex by your aim. In the framework side we design to have **only** one parameter needed, description. Other parameters are Optional.

| Attribute                    | Parameters        | Type                                               | Description                                                 |
| ---------------------------- | ----------------- | -------------------------------------------------- | ----------------------------------------------------------- |
| Description                  | `description`     | `str`                                              | A clear and concise statement of what the task.             |
| Response Format *(Optional)* | `response_format` | `Optional[List[Union(BaseModal, ObjectResponse)]]` | Define the reponse that you expect.                         |
| Tools *(Optional)*           | `tools`           | `Optional[List[Union(MCP, Function)]]`             | The needed tools to complete the task.                      |
| Context *(Optional)*         | `context`         | `Optional[List[Union(Task, KnowledgeBase, str)]]`  | The context that we want to agent while completing the task |

## Response Format

In Upsonic we support Pydantic BaseModel to define the requested result. With this you can get programmable results from agents. when you specify and response\_format the result will be object. With this object you can create an logic in your application.&#x20;

If you need to get list of cities it will return a list string. So you can focus on the value, not to the way.

<Note>
  You can use **Pydantic** `BaseModel` instead of `ObjectReponse`. We made this wrapper to make it easy to understand.
</Note>

```python
from upsonic import ObjectResponse

class TravelResponse(ObjectResponse):
  cities: str
```

```python
task1 = Task(
  description="Generate a plan to visit cities in Canada", 
  reponse_format=TravelResponse # Specift the response format
)
```

## Adding Tools to Task

The tools are one of the most important think of Agents. The tools are an bridge with LLM and the real world items. That can be an API, a service or an search engine query. In Upsonic we support variously.

The task can be in 2 format. First is Python function. You can write python functions as tool and use in Upsonic agents. The other format is Model Context Protocol (MCP) its general protocol for LLM tools. MCP tools can be base on Python, NodeJS and Docker. These tools developed by the Companies and Community. You can read more in [Tools](/tools) section.

To connect an tool you can put the tool Class name inside a list and define as `tools` in the Task object.

<Steps>
  <Step title="Function Tools">
    Now we will define a class called `MyTools` and we will put an `is_page_available` function. This function returns True if the given url accessible.

    ```python
    import requests

    @client.tool()
    class MyTools:

      def is_page_available(url: str) -> bool:
          return requests.get(url).status_code == 200

    ```
  </Step>

  <Step title="MCP Tools">
    In this example we will use the [HackerNews MCP Server](https://glama.ai/mcp/servers/e0rco8dfgt). Its provide `get_stories`, `get_story_info`, `search_stories`, and `get_user_info` functions itself. As you can see with MCP we can connect our agents to out services easily.

    ```python
    @client.mcp()
    class HackerNewsMCP:
        command = "uvx"
        args = ["mcp-hn"]
    ```
  </Step>

  <Step title="Put to Task">
    After creating these kind tools for your purposes, you can put to Task object directly. The agent will use these tools at required points.

    ```python
    tools = [Search, MyTools]

    task1 = Task(
      description="Summarize the latest hackernews stories of today", 
      tools=tools # Specify the tools list
    )
    ```
  </Step>
</Steps>

## Creating Chain of Task

Multiple tasks can handle more complex structures. This is important in comprehensive situations like creating an report after deep analyze. This tasks are enough complexity itself.  But the combination is our main aim. So, you can create a chain of `Task` .  You can connect task to another task via `context`.

```python
task1 = Task(description="Make an deep analyze to history of chips")

task2 = Task(
  description="Draft an report for Europe position.", 
  context=[task1] # Add task1 in a list as task context
)}
```

<Info>
  Upsonic framework explain the context to LLM for your purposes. Don't worry to share multiple contexts.
</Info>

## Giving string as Context

Tasks are the jobs that needs to complete. By the way, jobs have some variables like, url, name, person or topic. In first time we need to give an prompt and putting all to the prompt. This way seems cool. But not programmatic. You need to work with `f-strings` or `formats` and this disabling prompt management at the outside of your main flow.

In the context system we also support **str as context**. This provide an capability to put your variables to outside of the prompt.

<Tip>
  Use this when you need to separate your description and contexts like city list. If you have a prompt that don't have variable. You don't need to use it.
</Tip>

```python
city = "New Yorg"

task1 = Task(
  description="Find the resources in the city",
  context=[city] # Adding city string as context
)

```

And when you turn it to the production or you need to make it for different cities. You can use this way:

<Steps>
  <Step title="City List and Base Description">
    ```python
    cities = ["New Yorg", "San Fransisco", "San Jose"]
    base_description = "Find the resources in the city"
    ```
  </Step>

  <Step title="Creating a for loop">
    ```python
    tasks = []

    for city in cities:
      city_task = Task(
        description=base_description, # Setting description from base_description
        context=[city] # Setting city string as context
      )
      tasks.append(city_task)
    ```
  </Step>
</Steps>

## Running Task on Direct LLM Call

## Accessing to Task results

## Giving Knowledge Base as Context

## Running Task on Agent