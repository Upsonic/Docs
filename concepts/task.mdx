---
title: 'Task-Centric Structure'
description: 'Design your tasks in a crystal clear format.'
icon: bullseye
---

In the Upsonic framework, you can use the Task class to define your tasks. You can run tasks via agents or direct LLM calls. First, you need to define your tasks. Tasks also have some parameters, tools, and context. These definitions help you build comprehensive systems. With the context, you can link your task to another one or connect it to a knowledge base or a string.

**You don't have to create tasks like steps. The agent will automatically generate these steps for you.**

We made this tool so you'd have a clear understanding of the tasks.Other systems use non-task structures, and these systems have two problems.First, you can't use one agent for multiple tasks—in other words, you have to use one agent for only one task.The second problem is the lack of programmability.When you create a task, there are some dependencies, such as the website you referenced, the company you mentioned, or the competitor. You have to define these things inside your agent, and like the first problem, this creates an non-programmatic structure.You shouldn't create agents for every competitor analysis in a for loop.

## Creating a Task

The Task class is part of the upsonic, so it's pretty easy to import it. After the import, you can define tasks as "task1," "task2," "task3," and more.

```python
from upsonic import Task

task1 = Task(description="Do an in-depth analysis of US history")
```

## Task Attributest

The tasks can be basic or complex, depending on your goal. On the framework side, we design to have only one parameter needed: description. The other parameters are optional.

| Attribute                    | Parameters        | Type                                               | Description                                                 |
| ---------------------------- | ----------------- | -------------------------------------------------- | ----------------------------------------------------------- |
| Description                  | `description`     | `str`                                              | A clear and concise statement of what the task.             |
| Response Format *(Optional)* | `response_format` | `Optional[List[Union(BaseModal, ObjectResponse)]]` | Describe the response you expect.                         |
| Tools *(Optional)*           | `tools`           | `Optional[List[Union(MCP, Function)]]`             | The tools needed to complete the task.                      |
| Context *(Optional)*         | `context`         | `Optional[List[Union(Task, KnowledgeBase, str)]]`  | Context that helps accomplish the task |


## Adding Tools to a Task

Tools are a huge part of what agents do. They connect LLM with real-life items. Some examples are APIs, services, and search engines.

The tool can be in two type. First, you can use a Python function as a tool and use it in Upsonic agents. The other way is with Model Context Protocol (MCP), which is a general protocol for LLM tools. MCP tools can be based on Python, Node.js, and Docker. MCP tools are developed by companies and the community. You can read more in the "Tools" section.

If you want to connect a tool, just put the tool's class name in a list and define it as "tools" in the Task object.

<Steps>
  <Step title="Function Tools">
    So, first we're going to define a class called MyTools and add an is_page_available function. This function will return true if the given URL is accessible.

    ```python
    import requests

    @client.tool()
    class MyTools:

      def is_page_available(url: str) -> bool:
          return requests.get(url).status_code == 200

    ```
  </Step>

  <Step title="MCP Tools">
    In this example, we're going to use the [HackerNews MCP Server](https://glama.ai/mcp/servers/e0rco8dfgt). It provides functions like get_stories, get_story_info, search_stories, and get_user_info. As you can see, with MCP, we can connect our agents to our services easily.

    ```python
    @client.mcp()
    class HackerNewsMCP:
        command = "uvx"
        args = ["mcp-hn"]
    ```
  </Step>

  <Step title="Put to Task">
    After you connect these tools for your own use, you can put them to Task object directly. The agent will use these tools when needed.

    ```python
    tools = [Search, MyTools]

    task1 = Task(
      description="Summarize the latest hackernews stories of today", 
      tools=tools # Specify the tools list
    )
    ```
  </Step>
</Steps>

## Putting Task to Another Task as Context

You can use multiple tasks to handle more complex structures, which is really important in situations where you need to create a report after doing a deep analysis. These tasks are complex enough on their own, but combining them is our main goal in the example. So, you can create a chain of tasks and connect them via context.


```python
task1 = Task(description="Do an in-depth analysis of the history of chips")

task2 = Task(
  description="Prepare a draft report on Europe's position", 
  context=[task1] # Add task1 in a list as task context
)}
```

<Info>
  The Upsonic framework explains the context to the LLM for your purposes. You don't have to worry about sharing multiple contexts.
</Info>

## Giving Knowledge Base as Context

Your job is limited to the info on the LLM model. At some cases you need to attach some PDFs, docs, and spreadsheets to the task to finish it. For stuff like this, we've got this thing called the KnowledgeBase. It works with the Context system.

You can see the supported files and options of the <u>Knowledge Base System</u> [**from here**](/knowledge_base).

<Steps>
  <Step title="Define a KnowledgeBase">
    In this example, we'll use a PDF and a web link to make a knowledge base.

    ```python
    from upsonic import KnowledgeBase

    firm_knowledge_base = KnowledgeBase(
      files=["february_technical_tasks.pdf", "https://upsonic.ai"]
    )
    ```
  </Step>

  <Step title="Add as Context to Task">
    ```python
    task1 = Task(
      description="Create this month's overall technical report.",
      context=[firm_knowledge_base] # Adding firm_knowledge_base to task
    )
    ```
  </Step>
</Steps>

## Giving string as Context

Tasks are the things you need to get done. Task descriptions could have some variables, like a URL, name, person, or topic. At first way, we need to give all this stuffs in a a prompt. This way isn't programmatic. You need to work with f-strings or formats, and this disables prompt management outside of your main flow.

In the context system we also support **str as context**. This provide an capability to put your variables to outside of the prompt.

<Tip>
  Use this when you need to separate your prompt and variable, like in a city list. You don't need to use it if your prompt doesn't have variables.
</Tip>

```python
city = "New Yorg"

task1 = Task(
  description="Find resources in the city",
  context=[city] # Adding city string as context
)

```

When you need to create task for different cities, you can use this method:

<Steps>
  <Step title="City List and Base Description">
    ```python
    cities = ["New Yorg", "San Fransisco", "San Jose"]
    base_description = "Find resources in the city"
    ```
  </Step>

  <Step title="Creating a for loop">
    ```python
    tasks = []

    for city in cities:
      city_task = Task(
        description=base_description, # Setting description from base_description
        context=[city] # Setting city string as context
      )
      tasks.append(city_task)
    ```
  </Step>
</Steps>

## Response Format

In Upsonic we are compatible with Pydantic BaseModel to define the requested result. This lets you get programmable results from agents. When you specify the response format, the result will be an object. You can then use this object to create logic in your application.

If you need a list of cities, it'll give you a list of strings that include cities. So you can focus on the value instead of the way.

<Note>
  You can use Pydantic's BaseModel instead of ObjectResponse. We created this wrapper to make it easier to understand.
</Note>

```python
from upsonic import ObjectResponse

class TravelResponse(ObjectResponse):
  cities: str
```

```python
task1 = Task(
  description="Create a plan to visit cities in Canada", 
  reponse_format=TravelResponse # Specify the response format
)
```

## Running Task on Direct LLM Call

Once you've defined your task, you're all set to go. You can pick the runtime (Agent or direct LLM call). If your task is short and doesn't have possible sub-steps, the Agent side is just high cost in terms of time and money. You don't need to sub-task or characterize steps for some cases. You can position this feature for some tasks in your Agent application logic.

```python
task1 = Task(description="Describe planet Earth")

client.call(task1) # Direct and fast way to complete task
```

<Tip>
  Direct LLM Calls Support **<u>Tools</u>**

  Don't sweat it—Direct LLM Calls takes care of all your tools. They'll work like agents, no sweat!
</Tip>

## Running Task on Agent

You can run the task on the characterized LLM agents. This key concept means that the agents are specific and task-focused LLM's for your company. The agent mechanism works with "AgentConfiguration" objects, which define the characterization of the agent. 

You can view the details of agent creation and customization here.

<Steps>
  <Step title="Creating Agent">
    To create an agent, we're going to import the "AgentConfiguration" and make a basic customization.

    ```python
    from upsonic import AgentConfiguration

    product_manager_agent = AgentConfiguration(
        job_title="Product Manager",
        company_url="https://upsonic.ai",
        company_objective="To build AI Agent framework that helps people get things done",
    )
    ```
  </Step>

  <Step title="Creating Task">
    ```python
    task1 = Task(description="Make a deep analyze to history of chips")
    ```
  </Step>

  <Step title="Running Task with Agent">
    We've got a function called "agent" in the client that we'll use to give product_manager_agent and task1.

    ```python
    client.agent(product_manager_agent, task1)
    ```

    &#x20;
  </Step>
</Steps>

## Accessing to Task Results

There are two ways to run a task: direct LLM call or agent. They're runners for running the task and generating results. The runners can work in parallel or there can be multiple clients. We choose to store results in the Task object itself. This will generate an controllable infrastructure for your purposes.

When you run the task, the results are stored in the Task.response. You can get it directly.

```python
task1 = Task(description="Make a deep analyze to history of chips")

## Run the task

# client.call(task1)
# client.agent(product_manager_agent, task1)

## After Run the task

result = task1.response

print(response)
```

<Tip>
  Hey, just a heads-up: if you set a response_format, the task response will be an object of your class.

  ```python
  from upsonic import ObjectResponse

  class TravelResponse(ObjectResponse):
    cities: str

  task1 = Task(
    description="Generate a plan to visit cities in Canada", 
    reponse_format=TravelResponse # Specift the response format
  )

  ## Run the task

  # client.call(task1)
  # client.agent(product_manager_agent, task1)

  ## After Run the task


  result = task1.response

  print("Cities")
  for i in result.cities:
    print(i)
  ```
</Tip>

