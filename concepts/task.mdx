---
title: 'Task-Centric Structure'
description: 'Design your tasks in a crystal clear format.'
icon: bullseye
---

The tasks are define the job that we want to make done via agent. In Upsonic framework you can clearly define your task via `Task` class. The tasks can be run via agents or direct llm calls. As first of all your works, you need to define the task. Tasks are also have some parameters, `tools` and `context`. This definations helps you to build an comprehensive systems. With context, you can connect your task to another task or giving an knowledge base.

**You dont need to create tasks as step of your job. Agent will automatically generate this steps.**

We create this mechanism to be clear at the tasks. The other systems use interactions and non-task structures. This way create two problem; first, you cannot use the agents for varously tasks. In other way you need to use your agent for only one job. Second problem is non-programmatic situation. When you create an task. You have some dependencies like the website you reffered, the company you sad or the competitor. If you don't have systems like tasks. You need to define this things inside of your agent and like the first problem its creates an non-programmatic structure. You shouldn't create agents for every competitor analyses in a for loop.

## Creating a Task

Task class is belongs to `upsonic` so you can easily import. After the import you can define your task as task1, task2, task3 and more.&#x20;

```python
from upsonic import Task

task1 = Task(description="Making an deep analyze for US history")
```

## Task Attributest

The tasks are can be basic or complex by your aim. In the framework side we design to have **only** one parameter needed, description. Other parameters are Optional.

| Attribute                    | Parameters        | Type                                               | Description                                                 |
| ---------------------------- | ----------------- | -------------------------------------------------- | ----------------------------------------------------------- |
| Description                  | `description`     | `str`                                              | A clear and concise statement of what the task.             |
| Response Format *(Optional)* | `response_format` | `Optional[List[Union(BaseModal, ObjectResponse)]]` | Define the reponse that you expect.                         |
| Tools *(Optional)*           | `tools`           | `Optional[List[Union(MCP, Function)]]`             | The needed tools to complete the task.                      |
| Context *(Optional)*         | `context`         | `Optional[List[Union(Task, KnowledgeBase, str)]]`  | The context that we want to agent while completing the task |


## Adding Tools to Task

The tools are one of the most important think of Agents. The tools are an bridge with LLM and the real world items. That can be an API, a service or an search engine query. In Upsonic we support variously.

The task can be in 2 format. First is Python function. You can write python functions as tool and use in Upsonic agents. The other format is Model Context Protocol (MCP) its general protocol for LLM tools. MCP tools can be base on Python, NodeJS and Docker. These tools developed by the Companies and Community. You can read more in [Tools](/tools) section.

To connect an tool you can put the tool Class name inside a list and define as `tools` in the Task object.

<Steps>
  <Step title="Function Tools">
    Now we will define a class called `MyTools` and we will put an `is_page_available` function. This function returns True if the given url accessible.

    ```python
    import requests

    @client.tool()
    class MyTools:

      def is_page_available(url: str) -> bool:
          return requests.get(url).status_code == 200

    ```
  </Step>

  <Step title="MCP Tools">
    In this example we will use the [HackerNews MCP Server](https://glama.ai/mcp/servers/e0rco8dfgt). Its provide `get_stories`, `get_story_info`, `search_stories`, and `get_user_info` functions itself. As you can see with MCP we can connect our agents to out services easily.

    ```python
    @client.mcp()
    class HackerNewsMCP:
        command = "uvx"
        args = ["mcp-hn"]
    ```
  </Step>

  <Step title="Put to Task">
    After creating these kind tools for your purposes, you can put to Task object directly. The agent will use these tools at required points.

    ```python
    tools = [Search, MyTools]

    task1 = Task(
      description="Summarize the latest hackernews stories of today", 
      tools=tools # Specify the tools list
    )
    ```
  </Step>
</Steps>

## Putting Task to Another Task as Context

Multiple tasks can handle more complex structures. This is important in comprehensive situations like creating an report after deep analyze. This tasks are enough complexity itself.  But the combination is our main aim. So, you can create a chain of `Task` .  You can connect task to another task via `context`.

```python
task1 = Task(description="Make an deep analyze to history of chips")

task2 = Task(
  description="Draft an report for Europe position.", 
  context=[task1] # Add task1 in a list as task context
)}
```

<Info>
  Upsonic framework explain the context to LLM for your purposes. Don't worry to share multiple contexts.
</Info>

## Giving Knowledge Base as Context

Your task actually limited to LLM model informations and if you run in agent, automatic characterization of Upsonic. But still we need to put some **<u>PDFs</u>**<u>, **Docs**, **Excels**</u> to task to complete the job. At this kind of requests we have an mechanism called `KnowledgeBase`. The KnowledgeBase mechanism is compatible with Context system. You can give the **one or multiple** knowledge base as context.

You can see the supported files, options of <u>Knowledge Base System</u> [**from here**](/knowledge_base).

<Steps>
  <Step title="Define a KnowledgeBase">
    In this example we will put an **PDF** and a **Web Link** to create an `KnowledgeBase`.

    ```python
    from upsonic import KnowledgeBase

    firm_knowledge_base = KnowledgeBase(
      files=["february_technical_tasks.pdf", "https://upsonic.ai"]
    )
    ```
  </Step>

  <Step title="Add as Context to Task">
    ```python
    task1 = Task(
      description="Create a general technical report of this month.",
      context=[firm_knowledge_base] # Adding firm_knowledge_base to task
    )
    ```
  </Step>
</Steps>

## Giving string as Context

Tasks are the jobs that needs to complete. By the way, jobs have some variables like, url, name, person or topic. In first time we need to give an prompt and putting all to the prompt. This way seems cool. But not programmatic. You need to work with `f-strings` or `formats` and this disabling prompt management at the outside of your main flow.

In the context system we also support **str as context**. This provide an capability to put your variables to outside of the prompt.

<Tip>
  Use this when you need to separate your description and contexts like city list. If you have a prompt that don't have variable. You don't need to use it.
</Tip>

```python
city = "New Yorg"

task1 = Task(
  description="Find the resources in the city",
  context=[city] # Adding city string as context
)

```

And when you turn it to the production or you need to make it for different cities. You can use this way:

<Steps>
  <Step title="City List and Base Description">
    ```python
    cities = ["New Yorg", "San Fransisco", "San Jose"]
    base_description = "Find the resources in the city"
    ```
  </Step>

  <Step title="Creating a for loop">
    ```python
    tasks = []

    for city in cities:
      city_task = Task(
        description=base_description, # Setting description from base_description
        context=[city] # Setting city string as context
      )
      tasks.append(city_task)
    ```
  </Step>
</Steps>

## Response Format

In Upsonic we support Pydantic BaseModel to define the requested result. With this you can get programmable results from agents. when you specify and response\_format the result will be object. With this object you can create an logic in your application.&#x20;

If you need to get list of cities it will return a list string. So you can focus on the value, not to the way.

<Note>
  You can use **Pydantic** `BaseModel` instead of `ObjectReponse`. We made this wrapper to make it easy to understand.
</Note>

```python
from upsonic import ObjectResponse

class TravelResponse(ObjectResponse):
  cities: str
```

```python
task1 = Task(
  description="Generate a plan to visit cities in Canada", 
  reponse_format=TravelResponse # Specift the response format
)
```

## Running Task on Direct LLM Call

When you define your task its ready to action. You can choose the runtime (Agent or direct LLM call). If your task is short and don't have sub-steps. The agent side is just high cost of time and money. You dont need to sub tasks and characterization steps for some cases. You can positionate this feature for some tasks at your Agentic application logic.

```python
task1 = Task(description="Explain the World planet in the universe")

client.call(task1) # Direct and fast way to complete task
```

<Tip>
  Direct LLM Calls Support **<u>Tools</u>**

  You dont need to cut your tools when you use Direct LLM Calls.
</Tip>

## Running Task on Agent

You can run the task on the characterized LLM's, Agents. This key concept, The Agents mean **specific** and **task focused** LLM's for your company. The Agent mechanism working with `AgentConfiguration` objects. This objects defining the code resources of character of Agent.&#x20;

You can view the details of Agent creation and custominization [from here](/agent).

<Steps>
  <Step title="Creating Agent">
    To create an agent we will import the `AgentConfiguration` and make a basic custominization.

    ```python
    from upsonic import AgentConfiguration

    product_manager_agent = AgentConfiguration(
        job_title="Product Manager",
        company_url="https://upsonic.ai",
        company_objective="To build AI Agent framework that helps people get things done",
    )
    ```
  </Step>

  <Step title="Creating Task">
    ```python
    task1 = Task(description="Make an deep analyze to history of chips")
    ```
  </Step>

  <Step title="Running Task with Agent">
    In the client we have a function called `agent` with this we will give product\_manager\_agent and task1.

    ```python
    client.agent(product_manager_agent, task1)
    ```

    &#x20;
  </Step>
</Steps>

## Accessing to Task Results

There is two way to run an task. **Direct LLM Call** or **Agent**. They are runners for running the Task and generating result. The runners can be work <u>parallel</u> or <u>clients can be multiple</u>. By the way, we choose to store result in the `Task` object itself. It will generate an controllable infrastructure for your purposes.

When you run the task. The results storing in the `Task.response`. You can get it directly.

```python
task1 = Task(description="Make an deep analyze to history of chips")

## Run the task

# client.call(task1)
# client.agent(product_manager_agent, task1)

## After Run the task

result = task1.response

print(response)
```

<Tip>
  If you specify an `response_format`, the task response will be an **<u>object</u>** of your Class.

  ```python
  from upsonic import ObjectResponse

  class TravelResponse(ObjectResponse):
    cities: str

  task1 = Task(
    description="Generate a plan to visit cities in Canada", 
    reponse_format=TravelResponse # Specift the response format
  )

  ## Run the task

  # client.call(task1)
  # client.agent(product_manager_agent, task1)

  ## After Run the task


  result = task1.response

  print("Cities")
  for i in result.cities:
    print(i)
  ```
</Tip>

