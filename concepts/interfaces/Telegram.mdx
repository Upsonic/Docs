---
title: "Telegram"
sidebarTitle: "Telegram"
description: "Host agents as Telegram bots with webhooks, multi-media, and chat or task modes"
tag: "NEW"
---

Use the Telegram interface to serve Agents as Telegram bots. It mounts webhook and management routes on a FastAPI app and supports text, photos, documents, voice, video, stickers, location, polls, and inline keyboard callbacks.

## Prerequisites

Create a virtual environment and install the required dependencies:

```bash
uv venv
source .venv/bin/activate

uv pip install upsonic fastapi uvicorn
# pip install upsonic fastapi uvicorn
```

## Step 1: Create a Telegram Bot

1. Open Telegram and search for [@BotFather](https://t.me/BotFather)
2. Send `/newbot` and follow the prompts to choose a name and username
3. Copy the **Bot API Token** you receive — you'll need it in the next step

## Step 2: Set Up the Webhook with ngrok

Telegram delivers messages to your bot via **webhooks** — it sends HTTPS requests to a **public URL** you provide. Your local `localhost:8000` is not accessible from the internet, so you need a tunnel. We'll use [ngrok](https://ngrok.com/) for this.

<Steps>

<Step title="Create an ngrok account">
Go to [ngrok.com/signup](https://dashboard.ngrok.com/signup) and create a free account.
</Step>

<Step title="Install ngrok">
After signing up, follow the instructions on your [ngrok dashboard](https://dashboard.ngrok.com/get-started/setup) to install ngrok for your operating system.

<CodeGroup>

```bash macOS
brew install ngrok
```

```bash Linux
snap install ngrok
```

```bash Windows
choco install ngrok
```

</CodeGroup>
</Step>

<Step title="Connect your account">
Copy your authtoken from the [ngrok dashboard](https://dashboard.ngrok.com/get-started/your-authtoken) and run:

```bash
ngrok config add-authtoken YOUR_AUTH_TOKEN
```
</Step>

<Step title="Start the tunnel">
Open a terminal and run:

```bash
ngrok http 8000
```

You'll see output like this:

```
Forwarding  https://abc123.ngrok-free.app -> http://localhost:8000
```

Copy the `https://....ngrok-free.app` URL — this is your public webhook URL.
</Step>

</Steps>

<Warning>
Keep this terminal open — if you close ngrok, the tunnel stops and your bot won't receive messages. When you restart ngrok, the URL changes and you'll need to update your `.env` file.
</Warning>

## Step 3: Configure Environment Variables

Create a `.env` file with your credentials:

```bash
TELEGRAM_BOT_TOKEN=your-bot-token-from-botfather
TELEGRAM_WEBHOOK_URL=https://abc123.ngrok-free.app
```

<Tip>
`TELEGRAM_WEBHOOK_URL` is the ngrok URL you copied. When you restart ngrok, this URL changes — update it accordingly.
</Tip>

You can also set an optional secret for webhook validation:

```bash
TELEGRAM_WEBHOOK_SECRET=my-secret-token
```

## Step 4: Write Your Bot

There are two operating modes — pick the one that fits your use case:

- **CHAT** — The agent remembers conversation context per user. Best for conversational assistants.
- **TASK** — Each message is processed independently with no history. Best for one-off queries.

<CodeGroup>

```python CHAT Mode (Default)
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface, InterfaceMode

agent = Agent(
    model="openai/gpt-4o-mini",
    name="TelegramChatBot",
    system_prompt="You are a friendly AI assistant on Telegram. You remember conversation context.",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    webhook_secret=os.getenv("TELEGRAM_WEBHOOK_SECRET"),
    mode=InterfaceMode.CHAT,
    reset_command="/reset",
)

manager = InterfaceManager(interfaces=[telegram])
manager.serve(host="0.0.0.0", port=8000)
```

```python TASK Mode
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface, InterfaceMode

agent = Agent(
    model="openai/gpt-4o-mini",
    name="TelegramBot",
    system_prompt="You are a helpful AI assistant on Telegram. Be concise.",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    webhook_secret=os.getenv("TELEGRAM_WEBHOOK_SECRET"),
    mode=InterfaceMode.TASK,
)

manager = InterfaceManager(interfaces=[telegram])
manager.serve(host="0.0.0.0", port=8000)
```

</CodeGroup>

## Step 5: Run

Make sure ngrok is running in one terminal, then start your bot in another:

```bash
uv run your_bot.py
# python your_bot.py
```

Your bot is now live. Open Telegram, find your bot by username, and send a message.

## Operating Modes

* **TASK** (default) – Each message is processed as an independent task; no conversation history. Best for one-off queries and stateless bots.
* **CHAT** – Messages from the same user belong to a conversation session. The agent remembers context. Best for conversational assistants and support.

| Mode | Description | Best For |
| ---- | ----------- | -------- |
| **TASK** (default) | Each message is processed independently. No conversation history. | One-off queries, stateless bots |
| **CHAT** | Messages from the same user share a session. The agent remembers context. | Conversational assistants, support bots |

## Streaming

Set `stream=True` to progressively edit the Telegram message as tokens arrive from the agent. An initial message is sent immediately and then updated in-place as new chunks are generated. Updates are throttled to ~1 second intervals to respect Telegram rate limits. Works in both TASK and CHAT modes.

```python
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface

agent = Agent(
    model="openai/gpt-4o-mini",
    name="TelegramBot",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    mode="chat",
    stream=True,
)

manager = InterfaceManager(interfaces=[telegram])

if __name__ == "__main__":
    manager.serve(host="0.0.0.0", port=8000)
```

## Heartbeat

When used with an `AutonomousAgent` that has `heartbeat=True`, the interface periodically sends the agent's `heartbeat_message` to the agent, then delivers the response to the Telegram chat.

The target chat ID is resolved automatically from the first incoming message. You can also set it explicitly via `heartbeat_chat_id`.

```python
import os
from upsonic import AutonomousAgent
from upsonic.interfaces import InterfaceManager, TelegramInterface

agent = AutonomousAgent(
    model="openai/gpt-4o-mini",
    name="TelegramBot",
    heartbeat=True,
    heartbeat_period=30,
    heartbeat_message="Summarize any new updates.",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    mode="chat",
    # heartbeat_chat_id=1279809673,  # optional explicit override
)

manager = InterfaceManager(interfaces=[telegram])

if __name__ == "__main__":
    manager.serve(host="0.0.0.0", port=8000)
```

## Reset Command (CHAT mode only)

In CHAT mode, users can clear their conversation by sending the reset command (e.g. `/reset`) as a message. Configure it with `reset_command`; set to `None` to disable.

If the agent has a `workspace` configured, the reset command will also trigger a dynamic greeting message based on the workspace configuration. See [Workspace](/agents/advanced/workspace) for details.

## Access Control

Restrict your bot to specific users by passing a list of Telegram user IDs:

```python
telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    mode=InterfaceMode.CHAT,
    allowed_user_ids=[1279809673],
)
```

Users not in the list are ignored. Omit `allowed_user_ids` (or set `None`) to allow everyone.

## Example Usage

Create an agent, expose it with `TelegramInterface`, and serve via `InterfaceManager`. Example in **CHAT** mode with conversation history and reset:

```python
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface, InterfaceMode

def create_telegram_chat_bot():
    agent = Agent(
        model="openai/gpt-4o-mini",
        name="TelegramChatBot",
        system_prompt="""You are a friendly and helpful AI assistant on Telegram.
You can answer questions, help with coding, and have natural conversations.
When users send /reset, their conversation history will be cleared.
Be concise but helpful. Use emojis where appropriate.""",
        print=True,
    )

    telegram = TelegramInterface(
        agent=agent,
        name="TelegramChat",
        bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
        webhook_secret=os.getenv("TELEGRAM_WEBHOOK_SECRET"),
        webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
        mode=InterfaceMode.CHAT,
        reset_command="/reset",
        allowed_user_ids=[1279809673],
        parse_mode="HTML",
        disable_web_page_preview=False,
        disable_notification=False,
        protect_content=False,
        max_message_length=4096,
        reply_in_groups=True,
        reply_in_channels=False,
        process_edited_messages=False,
        process_callback_queries=True,
        typing_indicator=True,
    )

    return InterfaceManager(interfaces=[telegram])

if __name__ == "__main__":
    manager = create_telegram_chat_bot()
    manager.serve(host="0.0.0.0", port=8000, reload=False)
```

After starting, set the webhook (if not using `TELEGRAM_WEBHOOK_URL`):

```bash
curl -X POST 'http://localhost:8000/telegram/set-webhook?url=https://YOUR_DOMAIN/telegram/webhook'
```

Check health:

```bash
curl http://localhost:8000/telegram/health
```

## Core Components

* **`TelegramInterface`** – Wraps an Upsonic `Agent` for Telegram via FastAPI and Telegram Bot API.
* **`TelegramTools`** – Used internally for sending messages, files, chat actions, and webhook management.
* **`InterfaceManager.serve`** – Serves the FastAPI app (e.g. Uvicorn).

## `TelegramInterface` Interface

Main entry point for Upsonic Telegram bots.

### Initialization Parameters

| Parameter | Type | Default | Description |
| --------- | ---- | ------- | ----------- |
| `agent` | `Agent` | Required | Upsonic `Agent` instance. |
| `bot_token` | `Optional[str]` | `None` | Telegram Bot API token (or `TELEGRAM_BOT_TOKEN`). |
| `name` | `str` | `"Telegram"` | Interface name. |
| `mode` | `Union[InterfaceMode, str]` | `InterfaceMode.TASK` | `TASK` or `CHAT`. |
| `reset_command` | `Optional[str]` | `"/reset"` | Command to reset chat session (CHAT mode). Set `None` to disable. |
| `storage` | `Optional[Storage]` | `None` | Storage backend for chat sessions (CHAT mode). |
| `allowed_user_ids` | `Optional[List[int]]` | `None` | Whitelist of Telegram user IDs; `None` = allow all. |
| `webhook_secret` | `Optional[str]` | `None` | Secret for webhook validation (`X-Telegram-Bot-Api-Secret-Token`). |
| `webhook_url` | `Optional[str]` | `None` | Base URL for auto-setting webhook on startup. |
| `parse_mode` | `Optional[str]` | `"HTML"` | Default parse mode: `"HTML"`, `"Markdown"`, or `None`. |
| `disable_web_page_preview` | `bool` | `False` | Disable link previews in messages. |
| `disable_notification` | `bool` | `False` | Send messages silently. |
| `protect_content` | `bool` | `False` | Protect from forwarding/saving. |
| `reply_in_groups` | `bool` | `True` | Process messages in groups/supergroups. |
| `reply_in_channels` | `bool` | `False` | Process channel posts. |
| `process_edited_messages` | `bool` | `False` | Process edited messages. |
| `process_callback_queries` | `bool` | `True` | Handle inline keyboard callbacks. |
| `typing_indicator` | `bool` | `True` | Send "typing" chat action before replying. |
| `max_message_length` | `int` | `4096` | Max message length before splitting. |
| `stream` | `bool` | `False` | Stream agent responses by progressively editing the message. |
| `heartbeat_chat_id` | `Optional[int]` | `None` | Explicit Telegram chat ID for heartbeat delivery. Auto-detected from first incoming message if omitted. |

### Key Methods

| Method | Parameters | Return Type | Description |
| ------ | ---------- | ----------- | ----------- |
| `attach_routes` | None | `APIRouter` | Returns the FastAPI router with Telegram endpoints. |
| `health_check` | None | `Dict[str, Any]` | Returns health and configuration (bot, webhook, mode, whitelist). |
| `is_user_allowed` | `user_id: int` | `bool` | Returns whether the user is allowed (whitelist check). |

## Endpoints

Mounted under the `/telegram` prefix:

### `POST /telegram/webhook`

* Receives Telegram updates (messages, edited messages, channel posts, callback queries).
* Validates `X-Telegram-Bot-Api-Secret-Token` if `webhook_secret` is set.
* Processes updates in the background; responds with `200 {"ok": true}` so Telegram does not retry.

### `POST /telegram/set-webhook`

* Sets the bot webhook URL.
* Query/body: `url` (required), `secret_token` (optional), `drop_pending_updates` (optional, default `False`).
* Returns `{"success": bool}`.

### `POST /telegram/delete-webhook`

* Removes the current webhook.
* Query: `drop_pending_updates` (optional).
* Returns `{"success": bool}`.

### `GET /telegram/webhook-info`

* Returns current webhook status from Telegram (e.g. URL, pending update count).

### `GET /telegram/health`

* Health and status of the interface: bot connectivity, configuration (mode, whitelist, parse_mode, behavior flags), and optional bot info from Telegram.

## Supported File & Message Types

Users can send **any file type** through Telegram — images, PDFs, Excel spreadsheets, Word documents, CSVs, and more. The bot receives and forwards all of them to your agent.

* **Images** (PNG, JPG, etc.) – The agent can process these directly via its vision capabilities
* **PDFs, Excel, Word, CSV, and other documents** – The agent receives the file. If you equip your agent with the right tools (e.g. a PDF reader tool or an Excel parser), it can read and analyze the contents
* **Voice / Audio** – Downloaded and processed (e.g. transcription)
* **Video / Video note** – Downloaded and processed with caption
* **Text** – Processed as task or chat input
* **Sticker** – Converted to text (e.g. "User sent a sticker: {emoji}")
* **Location / Venue / Contact / Poll** – Converted to text and processed
* **Callback query** – Inline keyboard button data processed as text

<Tip>
Your agent can already handle images natively. For other file types like PDF or Excel, add a custom tool to your agent so it can read and process them. See [Custom Tools](/concepts/tools/custom-tools/overview) for how to create one.
</Tip>
