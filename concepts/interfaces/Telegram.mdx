---
title: "Telegram"
sidebarTitle: "Telegram"
description: "Host agents as Telegram bots with webhooks, multi-media, and chat or task modes"
tag: "NEW"
---

Use the Telegram interface to serve Agents as Telegram bots. It supports text, photos, documents, voice, video, stickers, location, polls, and inline keyboard callbacks.

## Prerequisites

Create a virtual environment and install the required dependencies:

```bash
uv venv
source .venv/bin/activate

uv pip install upsonic fastapi uvicorn
# pip install upsonic fastapi uvicorn
```

## Step 1: Create a Telegram Bot

1. Open Telegram and search for [@BotFather](https://t.me/BotFather)
2. Send `/newbot` and follow the prompts to choose a name and username
3. Copy the **Bot API Token** you receive — you'll need it in the next step

## Step 2: Set Up the Webhook with ngrok

Telegram delivers messages to your bot via **webhooks** — it sends HTTPS requests to a **public URL** you provide. Your local `localhost:8000` is not accessible from the internet, so you need a tunnel. We'll use [ngrok](https://ngrok.com/) for this.

<Steps>

<Step title="Create an ngrok account">
Go to [ngrok.com/signup](https://dashboard.ngrok.com/signup) and create a free account.
</Step>

<Step title="Install ngrok">
After signing up, follow the instructions on your [ngrok dashboard](https://dashboard.ngrok.com/get-started/setup) to install ngrok for your operating system.

<CodeGroup>

```bash macOS
brew install ngrok
```

```bash Linux
snap install ngrok
```

```bash Windows
choco install ngrok
```

</CodeGroup>
</Step>

<Step title="Connect your account">
Copy your authtoken from the [ngrok dashboard](https://dashboard.ngrok.com/get-started/your-authtoken) and run:

```bash
ngrok config add-authtoken YOUR_AUTH_TOKEN
```
</Step>

<Step title="Start the tunnel">
Open a terminal and run:

```bash
ngrok http 8000
```

You'll see output like this:

```
Forwarding  https://abc123.ngrok-free.app -> http://localhost:8000
```

Copy the `https://....ngrok-free.app` URL — this is your public webhook URL.
</Step>

</Steps>

<Warning>
Keep this terminal open — if you close ngrok, the tunnel stops and your bot won't receive messages. When you restart ngrok, the URL changes and you'll need to update your `.env` file.
</Warning>

## Step 3: Configure Environment Variables

Create a `.env` file with your credentials:

```bash
TELEGRAM_BOT_TOKEN=your-bot-token-from-botfather
TELEGRAM_WEBHOOK_URL=https://abc123.ngrok-free.app
```

<Tip>
`TELEGRAM_WEBHOOK_URL` is the ngrok URL you copied. When you restart ngrok, this URL changes — update it accordingly.
</Tip>

You can also set an optional secret for webhook validation:

```bash
TELEGRAM_WEBHOOK_SECRET=my-secret-token
```

## Step 4: Write Your Bot

There are two operating modes — pick the one that fits your use case:

- **CHAT** — The agent remembers conversation context per user. Best for conversational assistants.
- **TASK** — Each message is processed independently with no history. Best for one-off queries.

<CodeGroup>

```python CHAT Mode (Default)
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface, InterfaceMode

agent = Agent(
    model="openai/gpt-4o-mini",
    name="TelegramChatBot",
    system_prompt="You are a friendly AI assistant on Telegram. You remember conversation context.",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    webhook_secret=os.getenv("TELEGRAM_WEBHOOK_SECRET"),
    mode=InterfaceMode.CHAT,
    reset_command="/reset",
)

manager = InterfaceManager(interfaces=[telegram])
manager.serve(host="0.0.0.0", port=8000)
```

```python TASK Mode
import os
from upsonic import Agent
from upsonic.interfaces import InterfaceManager, TelegramInterface, InterfaceMode

agent = Agent(
    model="openai/gpt-4o-mini",
    name="TelegramBot",
    system_prompt="You are a helpful AI assistant on Telegram. Be concise.",
)

telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    webhook_secret=os.getenv("TELEGRAM_WEBHOOK_SECRET"),
    mode=InterfaceMode.TASK,
)

manager = InterfaceManager(interfaces=[telegram])
manager.serve(host="0.0.0.0", port=8000)
```

</CodeGroup>

## Step 5: Run

Make sure ngrok is running in one terminal, then start your bot in another:

```bash
uv run your_bot.py
# python your_bot.py
```

Your bot is now live. Open Telegram, find your bot by username, and send a message.

## Operating Modes

| Mode | Description | Best For |
| ---- | ----------- | -------- |
| **TASK** (default) | Each message is processed independently. No conversation history. | One-off queries, stateless bots |
| **CHAT** | Messages from the same user share a session. The agent remembers context. | Conversational assistants, support bots |

### Reset Command (CHAT mode only)

In CHAT mode, users can clear their conversation by sending `/reset`. Configure it with `reset_command`; set to `None` to disable.

If the agent has a `workspace` configured, the reset command will also trigger a dynamic greeting message based on the workspace configuration.

## Access Control

Restrict your bot to specific users by passing a list of Telegram user IDs:

```python
telegram = TelegramInterface(
    agent=agent,
    bot_token=os.getenv("TELEGRAM_BOT_TOKEN"),
    webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
    mode=InterfaceMode.CHAT,
    allowed_user_ids=[1279809673],
)
```

Users not in the list are ignored. Omit `allowed_user_ids` (or set `None`) to allow everyone.

## Supported Message Types

The bot can receive and process:

* **Text** – Processed as task or chat input
* **Photo** – Downloaded and sent to the agent with caption
* **Document** – Downloaded and processed; MIME type preserved
* **Voice / Audio** – Downloaded and processed (e.g. transcription)
* **Video / Video note** – Downloaded and processed with caption
* **Sticker** – Converted to text (e.g. "User sent a sticker: {emoji}")
* **Location / Venue / Contact / Poll** – Converted to text and processed
* **Callback query** – Inline keyboard button data processed as text
