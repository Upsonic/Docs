---
title: "Canvas"
description: "Allow your agent to perform high-quality text operations."
icon: "note-sticky"
---

## Overview

Agents working on text-based tasks are highly prone to rewriting the text unnecessarily, editing parts that shouldn't be modified, and introducing errors. This creates a process where developers must manually make adjustments and continuously implement checkpoints, especially when handling text-based use cases.

Within the Upsonic framework, we have a Canvas feature specifically designed to address this issue and provide a direct solution. This feature includes specialized and sensitive functions tailored for creating and editing a text canvas.

## Creating an Canvas

A Canvas is created with a specific name and can be assigned to a Task or class as a tool. This enables Agents or Direct operations to easily perform text edits.

```python
from upsonic.tools import Canvas

my_mail_canvas = Canvas("Mail to Joe") # Creating an canvas with an uniqe name
```

## Putting Canvas to Task

Canvas objects are immediately ready to be used as tools. You can add them directly as elements within the `tools` parameter of a Task, configuring your task to utilize this Canvas.

```python
from upsonic import Task

task = Task(
	"Write an mail to joe about our projects, Use Canvas",
	tools=[my_mail_canvas] # Adding canvas as tool
)
```

## Running Over an Agent

You can execute tasks equipped with the Canvas tool through an Agent.

```python
from upsonic import Agent

agent = Agent("Mail Writer")

agent.print_do(task)
```

## Running Over an Direct

You can execute tasks equipped with the Canvas tool through Direct.

```python
from upsonic import Direct

direct = Direct()

direct.print_do(task)
```

## Getting Current Canvas State

You can retrieve the final state of canvases executed via Agent or Direct by using the `get_current_state_of_canvas` function.

```python
result = my_mail_canvas.get_current_state_of_canvas()

print(result)
```