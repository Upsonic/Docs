---
title: "Overview"
description: "Integrate external tools using the Model Context Protocol"
---

## What is Model Context Protocol (MCP)?

The Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. It provides a standardized way for AI agents to communicate with external servers and access their capabilities.

## How MCP Works

MCP creates a bridge between your AI agents and external tool servers:

1. **Server Registration**: You configure an MCP server by specifying its connection details
2. **Tool Discovery**: The framework automatically discovers available tools from the server
3. **Tool Execution**: When your agent needs a tool, the framework handles communication with the MCP server
4. **Result Handling**: Results are returned to your agent in a standardized format

## Key Benefits

- **Extensive Ecosystem**: Access thousands of community-developed and official tools
- **No Custom Development**: Use pre-built tools without writing integration code
- **Standardized Protocol**: Consistent interface across different tool providers
- **Live Updates**: Servers can update tools without changing your code

## Three Ways to Use MCP

### 1. Class-Based

```python
from upsonic import Agent, Task

class DatabaseMCP:
    command = "uvx"
    args = ["mcp-server-sqlite", "--db-path", "/tmp/test_mcp_v7.db"]

agent = Agent(
    name="Legacy MCP Agent",
    role="Database operations specialist using legacy MCP class",
    goal="Demonstrate backward compatibility with class-based MCP",
    tool_call_limit=10
)

task = Task(
    description="""
    Create a 'products' table with columns: 
    - id (integer primary key)
    - name (text)
    - price (real)
    - category (text)
    - stock (integer)
    
    Insert 5 sample products with different categories (electronics, books, clothing).
    Then query and show all products sorted by price.
    """,
    tools=[DatabaseMCP]
)

result = agent.do(task)
print(result)
```

### 2. MCPHandler Class

```python
from upsonic import Agent, Task
from upsonic.tools.mcp import MCPHandler

mcp_handler = MCPHandler(
    command="uvx mcp-server-sqlite --db-path /tmp/db.db",
    timeout_seconds=60
)

agent = Agent(model="openai/gpt-4o")
task = Task(
    description="Query the database to list all tables and their schema information to understand the database structure.",
    tools=[mcp_handler]
)
result = agent.do(task)
print(result)
```

### 3. MultiMCPHandler Class (Multiple Servers)

```python
from upsonic import Agent, Task
from upsonic.tools.mcp import MultiMCPHandler

multi_handler = MultiMCPHandler(
    commands=[
        "uvx mcp-server-sqlite --db-path /tmp/db1.db",
        "uvx mcp-server-sqlite --db-path /tmp/db2.db",
    ],
    timeout_seconds=60
)

agent = Agent(model="openai/gpt-4o")
task = Task(
    description="Connect to both databases, query the user table from db1 and the products table from db2, and cross-reference the data.",
    tools=[multi_handler]
)
result = agent.do(task)
print(result)
```

## MCP Server Resources

Discover available MCP servers:
- [Glama MCP Servers](https://glama.ai/mcp/servers)
- [MCP Run](https://www.mcp.run/)
- [Smithery](https://smithery.ai/)

## Navigation

- [MCPHandler](/concepts/tools/mcp-tools/mcp-handler) - Use MCPHandler class for single server
- [MultiMCPHandler](/concepts/tools/mcp-tools/multi-mcp-handler) - Use MultiMCPHandler for multiple servers
- [MCP Types](/concepts/tools/mcp-tools/mcp-types/docker) - Configure Docker, NPX, SSE, and UVX-based MCP servers
- [Advanced Features](/concepts/tools/mcp-tools/advanced/authentication) - Configure authentication for MCP servers