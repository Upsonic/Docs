---
title: "Tools"
sidebarTitle: "Overview"
description: "Extend your AI agents with powerful tools"
hideToc: true
---

## What are Tools?

Tools are functions that agents can call to perform actions beyond text generation. They extend agents with capabilities like executing code, searching the web, accessing APIs, querying databases, processing files, and integrating with external systems.

When an agent needs to perform an action it can't do with language alone, it calls a tool. The agent decides which tool to use, what parameters to pass, and how to use the results to accomplish its task.

## Why use Tools?

Tools are essential for building practical AI agents:

- **Real-world actions**: Enable agents to interact with systems, not just generate text
- **Access external data**: Query APIs, databases, and services for up-to-date information
- **Extend capabilities**: Add domain-specific functionality (calculations, data processing, etc.)
- **Integrate systems**: Connect agents to your existing infrastructure and workflows
- **Ensure accuracy**: Use deterministic functions for tasks that require precision
- **Control execution**: Define exactly what agents can and cannot do

## Overview

Upsonic supports multiple tool types: custom Python functions, ToolKits, class methods, MCP (Model Context Protocol) tools, other agents as tools, and ready-to-use integrations. Tools can be configured with caching, retries, parallel execution, and safety policies.

## Key Features

- **Multiple Tool Types**: Custom, MCP, Model Provider, and Ready-to-Use tools
- **Flexible Configuration**: Control execution behavior, caching, and retries
- **Type Safety**: Automatic schema generation from Python type hints
- **Parallel Execution**: Run multiple tools simultaneously for better performance

## Supported Tool Types

The tools list accepts any combination of:

| Type | Example | Registered As |
|------|---------|---------------|
| Function tool | `@tool` decorated function | Function name |
| ToolKit instance | `DataProcessor()` | All `@tool` methods |
| Class instance | `Calculator()` | All public methods |
| Agent instance | `analyzer_agent` | `ask_{agent_name}` |
| MCP Handler | `MCPHandler(...)` | All MCP-provided tools |
| KnowledgeBase | `KnowledgeBase(...)` | `search_{kb_name}` |
| Builtin tools | `WebSearchTool()` | Provider-specific |

## Example

Create your own tools using Python functions or classes. Perfect for business logic, API integrations, and domain-specific functionality.

```python
from upsonic import Agent, Task
from upsonic.tools import tool

@tool
def calculate_discount(price: float, discount_percent: float) -> float:
    """Calculate the final price after applying a discount."""
    return price * (1 - discount_percent / 100)

# Create agent and task
agent = Agent("openai/gpt-4o")
task = Task(
    description="Calculate 20% discount on $100",
    tools=[calculate_discount]
)

# Execute task
result = agent.do(task)
print(result)
```

## Navigation

- [Custom Tools](/concepts/tools/custom-tools/overview) - Create your own tools using Python functions and classes
- [MCP Tools](/concepts/tools/mcp-tools/overview) - Integrate external tools using Model Context Protocol
- [Model Provider Tools](/concepts/tools/model-provider-tools/supported-providers) - Use built-in tools from model providers
- [Ready-to-Use Tools](/concepts/tools/ready-to-use-tools/duckduckgo) - Pre-built tools for common tasks
- [Tool Management](/concepts/tools/tool-management) - Add, remove, and manage tools dynamically
- [KnowledgeBase as Tool](/concepts/knowledgebase/using-as-tool) - Use KnowledgeBase for RAG-based tool calls
