---
title: "Custom Tools"
description: "Create powerful custom tools for your AI agents"
---

## Overview

Custom tools allow you to extend your AI agents with specialized functionality. Whether you need simple utility functions or complex business logic, Upsonic provides multiple approaches to create tools that integrate seamlessly with your agents.

### What are Custom Tools?

Custom tools are Python functions or classes that you create to give your AI agents specific capabilities. They can:
- Execute business logic and computations
- Integrate with external APIs and services
- Process and transform data
- Interact with databases and file systems
- Implement domain-specific algorithms

### Key Benefits

- **Flexible Creation**: Use functions, classes, or toolkits
- **Type Safety**: Automatic schema generation from type hints
- **Rich Configuration**: Control execution behavior, caching, retries, and more
- **Developer Friendly**: Minimal boilerplate with decorator-based approach

## Attributes

Custom tools support comprehensive configuration through the `@tool` decorator:

- **requires_confirmation**: Require user confirmation before execution
- **requires_user_input**: Prompt user for input during execution
- **user_input_fields**: Specify which fields require user input
- **external_execution**: Mark tool for external execution
- **show_result**: Display output to user instead of sending to LLM
- **stop_after_tool_call**: Terminate agent run after tool execution
- **sequential**: Enforce sequential execution (no parallelization)
- **cache_results**: Enable result caching
- **cache_dir**: Directory for cache storage
- **cache_ttl**: Cache time-to-live in seconds
- **tool_hooks**: Before/after execution hooks
- **max_retries**: Maximum retry attempts
- **timeout**: Execution timeout in seconds
- **strict**: Enforce strict JSON schema validation
- **docstring_format**: Docstring parsing format ('google', 'numpy', 'sphinx', 'auto')

## Creating Function Tool

### Overview

Function tools are the simplest way to create custom tools. Decorate any Python function with `@tool` to make it available to your agents.

### Example

```python
from upsonic import Agent, Task
from upsonic.tools import tool

@tool
def sum_tool(a: float, b: float) -> float:
    """
    Add two numbers together.
    
    Args:
        a: First number
        b: Second number
        
    Returns:
        The sum of a and b
    """
    return a + b

# Create task with the tool
task = Task(
    description="Calculate 15 + 27",
    tools=[sum_tool]
)

# Create agent
agent = Agent(model="openai/gpt-4o", name="Calculator Agent")

# Execute
agent.print_do(task)
```

## Creating ToolKit

### Overview

ToolKits allow you to organize related tools together in a class. Only methods decorated with `@tool` are exposed as tools to the agent.

### Example

```python
from upsonic import Agent, Task
from upsonic.tools import tool, ToolKit

class CalculatorToolKit(ToolKit):
    """A toolkit for mathematical operations."""
    
    @tool
    def add(self, a: float, b: float) -> float:
        """
        Add two numbers.
        
        Args:
            a: First number
            b: Second number
            
        Returns:
            Sum of a and b
        """
        return a + b
    
    @tool
    def subtract(self, a: float, b: float) -> float:
        """
        Subtract b from a.
        
        Args:
            a: First number
            b: Second number
            
        Returns:
            Difference of a and b
        """
        return a - b
    
    @tool
    def multiply(self, a: float, b: float) -> float:
        """
        Multiply two numbers.
        
        Args:
            a: First number
            b: Second number
            
        Returns:
            Product of a and b
        """
        return a * b
    
    @tool
    def divide(self, a: float, b: float) -> float:
        """
        Divide a by b.
        
        Args:
            a: Numerator
            b: Denominator
            
        Returns:
            Quotient of a and b
        """
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b

# Create task with the toolkit
task = Task(
    description="Calculate (15 + 27) * 2 and then divide by 3",
    tools=[CalculatorToolKit()]
)

# Create agent
agent = Agent(model="openai/gpt-4o", name="Math Agent")

# Execute
agent.print_do(task)
```

## Tool Configurations

### Required Confirmation

Require user confirmation before executing a tool.

**Usage:**

```python
from upsonic.tools import tool

@tool(requires_confirmation=True)
def delete_file(file_path: str) -> str:
    """
    Delete a file from the system.
    
    Args:
        file_path: Path to the file to delete
        
    Returns:
        Confirmation message
    """
    import os
    os.remove(file_path)
    return f"File {file_path} deleted successfully"
```

**Parameters:**
- `requires_confirmation` (bool): If True, prompts user with "Proceed? (y/n)" before execution

### Requires User Input

Prompt the user for input during tool execution.

**Usage:**

```python
from upsonic.tools import tool

@tool(
    requires_user_input=True,
    user_input_fields=["username", "password"]
)
def secure_login(username: str, password: str) -> str:
    """
    Login with user-provided credentials.
    
    Args:
        username: Username for login
        password: Password for login
        
    Returns:
        Login status message
    """
    return f"Login successful for user: {username}"
```

**Parameters:**
- `requires_user_input` (bool): If True, prompts user for specified fields
- `user_input_fields` (List[str]): List of parameter names to request from user

### User Input Fields

Specify which fields require user input.

**Usage:**

```python
from upsonic.tools import tool

@tool(
    requires_user_input=True,
    user_input_fields=["api_key"]
)
def api_call(endpoint: str, api_key: str) -> str:
    """
    Make an API call with user-provided key.
    
    Args:
        endpoint: API endpoint URL
        api_key: API authentication key
        
    Returns:
        API response
    """
    return f"API call to {endpoint} completed"
```

**Parameters:**
- `user_input_fields` (List[str]): List of field names that require user input

### External Execution

Mark a tool for execution outside the framework.

**Usage:**

```python
from upsonic.tools import tool

@tool(external_execution=True)
def external_database_query(query: str) -> str:
    """
    Execute a database query externally.
    
    Args:
        query: SQL query to execute
        
    Returns:
        Query results
    """
    return f"Query executed: {query}"

# Usage with external execution handling
task = Task(
    description="Query the database",
    tools=[external_database_query]
)

agent = Agent(model="openai/gpt-4o")
result = await agent.do_async(task)

# Handle external execution
if task.is_paused and task.tools_awaiting_external_execution:
    for external_call in task.tools_awaiting_external_execution:
        # Execute the actual external operation
        result = external_database_query(**external_call.args)
        external_call.result = result
    
    # Continue execution
    final_result = agent.continue_run(task)
```

**Parameters:**
- `external_execution` (bool): If True, pauses agent execution for external tool handling

### Show Result

Display tool output to the user instead of sending it back to the LLM.

**Usage:**

```python
from upsonic.tools import tool

@tool(show_result=True)
def display_report(data: str) -> str:
    """
    Generate and display a report.
    
    Args:
        data: Data to include in report
        
    Returns:
        Formatted report
    """
    return f"=== REPORT ===\n{data}\n=============="
```

**Parameters:**
- `show_result` (bool): If True, displays output to user and doesn't send to LLM

### Stop After Tool Call

Terminate the agent's run after this tool executes.

**Usage:**

```python
from upsonic.tools import tool

@tool(
    stop_after_tool_call=True,
    show_result=True
)
def final_answer(answer: str) -> str:
    """
    Provide final answer and stop execution.
    
    Args:
        answer: The final answer
        
    Returns:
        Final answer message
    """
    return f"Final Answer: {answer}"
```

**Parameters:**
- `stop_after_tool_call` (bool): If True, terminates agent execution after this tool runs

### Sequential & Parallel Run

Control whether a tool can be executed in parallel with others.

**Usage:**

```python
from upsonic.tools import tool

@tool(sequential=True)
def database_transaction(operation: str, data: str) -> str:
    """
    Execute a database transaction that must run sequentially.
    
    Args:
        operation: Transaction type
        data: Transaction data
        
    Returns:
        Transaction result
    """
    return f"Transaction {operation} completed with data: {data}"
```

**Parameters:**
- `sequential` (bool): If True, tool must execute sequentially (no parallelization)

### Caching

Enable result caching to avoid redundant executions.

**Usage:**

```python
from upsonic.tools import tool

@tool(
    cache_results=True,
    cache_ttl=3600,  # Cache for 1 hour
    cache_dir="/tmp/tool_cache"
)
def expensive_computation(n: int) -> int:
    """
    Perform an expensive computation with caching.
    
    Args:
        n: Input number
        
    Returns:
        Computation result
    """
    import time
    time.sleep(2)  # Simulate expensive operation
    return n ** 2
```

**Parameters:**
- `cache_results` (bool): Enable caching
- `cache_ttl` (int): Cache time-to-live in seconds
- `cache_dir` (str): Directory for cache storage (default: ~/.upsonic/cache)

### Tool Hooks

Execute custom logic before and after tool execution.

**Usage:**

```python
from upsonic.tools import tool, ToolHooks

def before_execution(**kwargs):
    print(f"Starting execution with args: {kwargs}")
    return {"start_time": time.time()}

def after_execution(result):
    print(f"Execution completed with result: {result}")
    return {"end_time": time.time()}

@tool(
    tool_hooks=ToolHooks(before=before_execution, after=after_execution)
)
def monitored_operation(data: str) -> str:
    """
    Operation with before/after hooks.
    
    Args:
        data: Input data
        
    Returns:
        Processed data
    """
    return data.upper()
```

**Parameters:**
- `tool_hooks` (ToolHooks): Object with `before` and `after` callables

### Timeout

Set execution timeout for a tool.

**Usage:**

```python
from upsonic.tools import tool

@tool(
    timeout=30.0,  # 30 seconds timeout
    max_retries=3
)
def api_request(url: str) -> str:
    """
    Make an API request with timeout.
    
    Args:
        url: URL to request
        
    Returns:
        API response
    """
    import requests
    response = requests.get(url)
    return response.text
```

**Parameters:**
- `timeout` (float): Timeout in seconds (default: 30.0)
- `max_retries` (int): Number of retries on timeout (default: 5)

### Strict

Enforce strict JSON schema validation on tool parameters.

**Usage:**

```python
from upsonic.tools import tool

@tool(strict=True)
def validate_input(name: str, age: int, email: str) -> str:
    """
    Process user data with strict validation.
    
    Args:
        name: User's full name
        age: User's age
        email: User's email address
        
    Returns:
        Validation result
    """
    return f"Validated: {name}, {age}, {email}"
```

**Parameters:**
- `strict` (bool): If True, enforces strict JSON schema validation

### Docstring Format

Specify the docstring format for parameter description extraction.

**Usage:**

```python
from upsonic.tools import tool

@tool(docstring_format='google')
def process_data(input_data: str, format_type: str) -> str:
    """
    Process data with specified format.
    
    Args:
        input_data: The data to process
        format_type: Format type for processing
        
    Returns:
        Processed data result
    """
    return f"Processed {input_data} as {format_type}"
```

**Parameters:**
- `docstring_format` (str): Format type - 'google', 'numpy', 'sphinx', or 'auto' (default: 'auto')

## Advanced

### Agent as Tool

Use other agents as tools for hierarchical agent architectures.

**Usage:**

```python
from upsonic import Agent, Task

# Create a specialized agent
research_agent = Agent(
    name="Research Specialist",
    model="openai/gpt-4o",
    system_prompt="You are a research specialist focused on gathering information."
)

# Use the specialized agent as a tool
task = Task(
    description="Research current AI trends and provide a summary",
    tools=[research_agent]
)

# Main agent delegates to specialized agent
main_agent = Agent(
    name="Main Coordinator",
    model="openai/gpt-4o"
)

main_agent.print_do(task)
```

**Parameters:**
- Any agent instance can be used as a tool
- The agent's `name`, `role`, `goal`, and `system_prompt` are used to generate the tool description
- Tool name format: `ask_{agent_name}`

### Combining Multiple Tools

Combine different types of tools in a single task.

**Usage:**

```python
from upsonic import Agent, Task
from upsonic.tools import tool, ToolKit

# Function tool
@tool
def fetch_data(source: str) -> str:
    """Fetch data from source."""
    return f"Data from {source}"

# ToolKit
class DataProcessor(ToolKit):
    @tool
    def transform(self, data: str) -> str:
        """Transform data."""
        return data.upper()
    
    @tool
    def validate(self, data: str) -> bool:
        """Validate data."""
        return len(data) > 0

# Specialized agent
analyzer_agent = Agent(
    name="Data Analyzer",
    model="openai/gpt-4o",
    system_prompt="Analyze data patterns"
)

# Combine all tools
task = Task(
    description="Fetch, process, validate, and analyze data",
    tools=[
        fetch_data,
        DataProcessor(),
        analyzer_agent
    ]
)

agent = Agent(model="openai/gpt-4o", name="Main Agent")
agent.print_do(task)
```

**Parameters:**
- Tools list accepts: functions, ToolKit instances, class instances, and agent instances
- All tools are registered and available to the agent during execution
- Tools can be called in any order based on the agent's reasoning
