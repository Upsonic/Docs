---
title: "MCP Tools"
description: "Integrate external tools using the Model Context Protocol"
---

## Overview

### What is Model Context Protocol (MCP)?

The Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. It provides a standardized way for AI agents to communicate with external servers and access their capabilities.

### How MCP Works

MCP creates a bridge between your AI agents and external tool servers:

1. **Server Registration**: You configure an MCP server by specifying its connection details
2. **Tool Discovery**: The framework automatically discovers available tools from the server
3. **Tool Execution**: When your agent needs a tool, the framework handles communication with the MCP server
4. **Result Handling**: Results are returned to your agent in a standardized format

### Key Benefits

- **Extensive Ecosystem**: Access thousands of community-developed and official tools
- **No Custom Development**: Use pre-built tools without writing integration code
- **Standardized Protocol**: Consistent interface across different tool providers
- **Live Updates**: Servers can update tools without changing your code

### MCP Server Resources

Discover available MCP servers:
- [Glama MCP Servers](https://glama.ai/mcp/servers)
- [MCP Run](https://www.mcp.run/)
- [Smithery](https://smithery.ai/)

## MCP Types

### SSE Server

Server-Sent Events (SSE) based servers for remote MCP tool access.

**Usage:**

```python
from upsonic import Task, Agent

# Define SSE-based MCP servers
class FetchMCP:
    url = "https://your-mcp-server.com/sse"

class SearchMCP:
    url = "https://search-mcp-server.com/sse"

# Create task with MCP tools
task = Task(
    description="Use the fetch tool to get latest news in Europe",
    tools=[FetchMCP, SearchMCP]
)

# Create agent
agent = Agent(
    name="News Agent",
    model="openai/gpt-4o"
)

# Execute
agent.print_do(task)
```

**Parameters:**
- `url` (str): The SSE endpoint URL of the MCP server

**Characteristics:**
- Remote server access over HTTP
- Real-time event streaming
- Suitable for cloud-hosted MCP servers
- No local installation required

### NPX Based

Node.js package runner based MCP servers.

**Usage:**

```python
from upsonic import Task, Agent

# NPX-based MCP server (requires Node.js installed)
class GitHubMCP:
    command = "npx"
    args = ["-y", "@modelcontextprotocol/server-github"]
    env = {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "your_token_here"
    }

# Create task
task = Task(
    description="Check my GitHub repositories and list recent commits",
    tools=[GitHubMCP]
)

# Create agent
agent = Agent(
    name="GitHub Agent",
    model="openai/gpt-4o"
)

# Execute
agent.print_do(task)
```

**Parameters:**
- `command` (str): The command to run ("npx")
- `args` (List[str]): Arguments including package name and flags
- `env` (Dict[str, str]): Environment variables (optional)

**Requirements:**
- Node.js and npm must be installed on your system
- Package is downloaded on first use

### UVX

Python-based MCP servers using the uvx package runner.

**Usage:**

```python
from upsonic import Task, Agent

# UVX-based MCP server (Python-based, no installation needed)
class FetchMCP:
    command = "uvx"
    args = ["mcp-server-fetch"]

class FileSystemMCP:
    command = "uvx"
    args = ["mcp-server-filesystem"]

# Create task
task = Task(
    description="Fetch data from the web and save to file system",
    tools=[FetchMCP, FileSystemMCP]
)

# Create agent
agent = Agent(
    name="Data Fetcher",
    model="openai/gpt-4o"
)

# Execute
agent.print_do(task)
```

**Parameters:**
- `command` (str): The command to run ("uvx")
- `args` (List[str]): Arguments including package name

**Characteristics:**
- Python-based MCP servers
- Automatic dependency management
- No manual installation required
- Isolated execution environment

### Docker

Docker container-based MCP servers for maximum isolation.

**Usage:**

```python
from upsonic import Task, Agent

# Docker-based MCP server
class DatabaseMCP:
    command = "docker"
    args = [
        "run",
        "--rm",
        "-i",
        "--network", "host",
        "your-mcp-server-image:latest"
    ]
    env = {
        "DATABASE_URL": "postgresql://localhost/mydb"
    }

# Create task
task = Task(
    description="Query the database and analyze results",
    tools=[DatabaseMCP]
)

# Create agent
agent = Agent(
    name="Database Agent",
    model="openai/gpt-4o"
)

# Execute
agent.print_do(task)
```

**Parameters:**
- `command` (str): The command to run ("docker")
- `args` (List[str]): Docker run arguments including image name
- `env` (Dict[str, str]): Environment variables to pass to container

**Requirements:**
- Docker must be installed and running
- MCP server Docker image must be available

**Characteristics:**
- Maximum isolation and security
- Consistent environment across systems
- Easy deployment and versioning
- Network and resource control

## Advanced

### Authentication

Configure authentication for MCP servers that require credentials.

**Usage:**

```python
from upsonic import Task, Agent

# MCP server with authentication
class AuthenticatedMCP:
    command = "npx"
    args = ["-y", "@company/private-mcp-server"]
    env = {
        "API_KEY": "your_api_key_here",
        "API_SECRET": "your_api_secret_here",
        "AUTH_TOKEN": "bearer_token_here"
    }

# Multiple servers with different auth
class GitHubMCP:
    command = "npx"
    args = ["-y", "@modelcontextprotocol/server-github"]
    env = {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "ghp_xxxxx"
    }

class SlackMCP:
    command = "uvx"
    args = ["mcp-server-slack"]
    env = {
        "SLACK_BOT_TOKEN": "xoxb-xxxxx",
        "SLACK_TEAM_ID": "T1234567"
    }

# Create task with authenticated tools
task = Task(
    description="Check GitHub issues and notify the team on Slack",
    tools=[GitHubMCP, SlackMCP]
)

# Create agent
agent = Agent(
    name="Integration Agent",
    model="openai/gpt-4o"
)

# Execute
agent.print_do(task)
```

**Parameters:**
- `env` (Dict[str, str]): Dictionary of environment variables for authentication
  - Common keys: `API_KEY`, `API_SECRET`, `AUTH_TOKEN`, `ACCESS_TOKEN`
  - Service-specific keys: `GITHUB_PERSONAL_ACCESS_TOKEN`, `SLACK_BOT_TOKEN`, etc.

**Best Practices:**
- Store credentials securely (use environment variables or secrets management)
- Never hardcode credentials in source code
- Use separate credentials for development and production
- Rotate credentials regularly
- Follow the principle of least privilege

**Example with Environment Variables:**

```python
import os
from upsonic import Task, Agent

# Load from environment
class SecureMCP:
    command = "npx"
    args = ["-y", "@company/mcp-server"]
    env = {
        "API_KEY": os.getenv("MCP_API_KEY"),
        "API_SECRET": os.getenv("MCP_API_SECRET")
    }

task = Task(
    description="Use authenticated MCP server",
    tools=[SecureMCP]
)

agent = Agent(name="Secure Agent", model="openai/gpt-4o")
agent.print_do(task)
```

**SSE Server Authentication:**

```python
from upsonic import Task, Agent

# SSE server with authentication headers
class AuthenticatedSSE:
    url = "https://mcp-server.com/sse"
    # Note: Authentication for SSE typically handled server-side
    # Pass credentials via URL parameters or configure server-side

task = Task(
    description="Use authenticated SSE MCP server",
    tools=[AuthenticatedSSE]
)

agent = Agent(name="SSE Agent", model="openai/gpt-4o")
agent.print_do(task)
```

**Troubleshooting Authentication:**

Common authentication issues:
- **Invalid credentials**: Verify tokens and keys are correct
- **Expired tokens**: Refresh or regenerate authentication tokens
- **Permission errors**: Ensure credentials have required scopes/permissions
- **Network errors**: Check firewall and proxy settings for authenticated connections
